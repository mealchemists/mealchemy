import fractions
from django.contrib.auth.models import User
from django.contrib.postgres.search import TrigramSimilarity
from django.db import models

from backend.models import TimeStampedModel

from .units import CountUnit, MassUnit, Unit, VolumeUnit


class Aisle(TimeStampedModel):
    name = models.CharField(max_length=255, unique=True)
    llm_generated = models.BooleanField(
        default=False
    )  # Flag to mark if the tag was generated by LLM
    updated_by_user = models.BooleanField(
        default=False
    )  # To track if a user modified the tag
    user = models.ForeignKey(User, on_delete=models.CASCADE, null=True)

class Ingredient(models.Model):
    name = models.CharField(max_length=255, unique=True)

    # NOTE: USDA FoodData Central API uses kcal; this is the same thing as actual Calories.
    calories_per_100g = models.FloatField(
        help_text="energy in kcal per 100g", null=True
    )
    protein_per_100g = models.FloatField(
        help_text="grams of protein per 100g", null=True
    )
    carbs_per_100g = models.FloatField(
        help_text="grams of carbohydrates per 100g", null=True
    )
    sugar_per_100g = models.FloatField(help_text="grams of sugar per 100g", null=True)
    fat_per_100g = models.FloatField(help_text="grams of total fat per 100g", null=True)
    fiber_per_100g = models.FloatField(help_text="grams of fiber per 100g", null=True)
    sodium_per_100mg = models.FloatField(help_text="mg of sodium per 100g")

    aisle = models.ForeignKey(Aisle, on_delete=models.SET_NULL, null=True, blank=True)
    needs_review = models.BooleanField(default=True)
    
    @classmethod
    def find_best_match(cls, name, threshold=0.6):
        """
        Finds the closest matching ingredient in the database using trigram similarity.
        """

        match = (
            cls.objects.annotate(similarity=TrigramSimilarity("name", name))
            .filter(similarity__gte=threshold)
            .order_by("-similarity")
            .first()
        )
        if match is None:
            raise ValueError("Not found!")
        return match

    def save(self, *args, **kwargs):
        # TODO: Query the FoodData Central API and process the contents.
        # If the API fails, prompt the user to manually enter the nutrition information.
        
        # Determine if the recipe needs review
        
        #TODO nutriotion info?
        self.needs_review = not (self.name and self.aisle)

        
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.name}"


class RecipeIngredient(TimeStampedModel):
    recipe = models.ForeignKey(
        "recipes.Recipe", related_name="recipe_ingredients", on_delete=models.CASCADE
    )
    ingredient = models.ForeignKey(Ingredient, on_delete=models.CASCADE)
    quantity = models.CharField(max_length=255, null=True)
    # NOTE: When we are creating a new RecipeIngredient, we explicitly mention the Unit enum,
    # which is then internally translated to its respective label within the model.
    unit = models.CharField(max_length=255, null=True, blank=True)
    # NOTE: display_name can vary -- this should come from the PDF/website/manual entry.
    # ingredient.name should be the raw name from the USDA FoodData Central API
    display_name = models.CharField(
        max_length=255, null=True, blank=False, default=ingredient.name
    )
    needs_review = models.BooleanField(default=True)

    class Meta(TimeStampedModel.Meta):
        """
        A Recipe cannot have the same RecipeIngredient more than once.
        However, the same Ingredient can exist in multiple Recipes.

        For example, this would throw an IntregrityError if we have Recipe A
        that takes in RecipeIngredient 'flour' with 4 cups, and we want to add
        create a new RecipeIngredient 'flour' under Recipe A that takes in 1 cup.
        """

        unique_together = ("recipe", "ingredient")

    def save(self, *args, **kwargs):
        """
        If an Enum is passed as a unit, then make sure that its
        label is stored in the database.
        """
        if isinstance(self.unit, Unit):
            self.unit = self.unit.label
            
        self.needs_review = not (self.quantity and self.unit)
        super().save(*args, **kwargs)

    def _get_unit_enum(self):
        """
        Retrieves the corresponding Unit (enum) instance based
        on the given instance's unit in string format.
        """
        for unit_enum in (VolumeUnit, MassUnit, CountUnit):
            for unit in unit_enum:
                if unit.label == self.unit:
                    return unit
            raise LookupError("Unit not found!")

    def _to_base_unit(self):
        """
        Converts the stored quantity to g or mL if applicable.
        This will likely be used when it comes to calculating
        the total nutrition for a selection of RecipeIngredients.
        """
        unit_enum = self._get_unit_enum()
        if isinstance(unit_enum, CountUnit):
            return self.quantity
        if unit_enum:
            return unit_enum.to_base_unit(self.quantity)

    def __str__(self):
        # TODO: properly handle pluralization (tomato -> tomatoes, pineapple -> pineapples)
        # For now, I am going to use single form.
        unit_enum = self._get_unit_enum()
        if isinstance(unit_enum, CountUnit):
            return f"{self.quantity}x {self.display_name}"

        # Attempt to format the quantity to fraction up to a 16th.
        fraction = fractions.Fraction(self.quantity).limit_denominator(16)
        if fraction.denominator == 1:
            formatted_quantity = fraction.numerator
        else:
            formatted_quantity = f"{fraction.numerator}/{fraction.denominator}"

        unit = self.unit if self.quantity <= 1 else f"{self.unit}s"

        return f"{formatted_quantity} {unit} of {self.display_name}"
